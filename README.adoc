= ip2unix(1)
ifndef::manmanual[:doctitle: IP2Unix]
:revdate: October 2018
ifndef::manmanual[]
:toc: macro
:numbered:
:toc-title:

*Table of Contents*

toc::[]
endif::[]

ifdef::manmanual[]
== Name

ip2unix - Turn IP sockets into Unix domain sockets

== Synopsis

*ip2unix* [-p] -f RULES_FILE        PROGRAM [ARGS...] +
*ip2unix* [-p] -F RULES_DATA        PROGRAM [ARGS...] +
*ip2unix* [-p] -r RULE [-r RULE]... PROGRAM [ARGS...] +
*ip2unix* [-p] -c -f RULES_FILE +
*ip2unix* [-p] -c -F RULES_DATA +
*ip2unix* [-p] -c -r RULE [-r RULE]... +
*ip2unix* -h

endif::[]

ifndef::manmanual[]
:1: http://man7.org/linux/man-pages/man8/ld.so.8.html#ENVIRONMENT
:2: http://man7.org/linux/man-pages/man2/accept.2.html
:3: https://www.freedesktop.org/software/systemd/man/systemd.socket.html
:4: pass:attributes,quotes[{3}#FileDescriptorName=]

:LD_PRELOAD: pass:attributes,quotes[*`LD_PRELOAD`* ({1}[*ld.so*(8)])]
:syscall_accept: pass:attributes,quotes[{2}[*accept*(2)]]
:systemd_socket: pass:attributes,quotes[{3}[*systemd.socket*(5)]]
:fdname: pass:attributes,quotes[{4}[FileDescriptorName]]
:rulefileformat: <<Rule file format>>
endif::[]
ifdef::manmanual[]
:LD_PRELOAD: pass:quotes[*`LD_PRELOAD`* (see *ld.so*(8))]
:syscall_accept: pass:quotes[*accept*(2)]
:systemd_socket: pass:quotes[*systemd.socket*(5)]
:fdname: pass:quotes[FileDescriptorName (see *systemd.socket*(5))]
:rulefileformat: pass:quotes[*RULE FILE FORMAT*]
endif::[]

:lgpl_url: https://www.gnu.org/licenses/lgpl-3.0.html

ifndef::without-systemd[:systemd_comma: ,]
ifdef::without-systemd[:systemd_comma:]

ifndef::without-systemd[:systemd_backslash: \]
ifdef::without-systemd[:systemd_backslash:]

== Description

Turns IP sockets into Unix domain socket based on a list of rules (see
{rulefileformat} below) specified via YAML/JSON file. This is done by the use
of {LD_PRELOAD} environment variable and you can either directly specify the
path of *`ip2unix`* via *`LD_PRELOAD`* or use the *`ip2unix`* command directly
(it is a library and executable at the same time).

In order for the direct *`LD_PRELOAD`* variant to work, you also have to
specify the *`IP2UNIX_RULE_FILE`* environment variable.

ifndef::manmanual[]

Use `ip2unix --help` or `man ip2unix` to see a detailed list of options
available.

endif::[]

ifdef::manmanual[]

== Options

*-c, --check*::
  This is to validate whether the rule file is correct and the program
  just prints all validation errors to stderr and exits with exit code *0*
  if validation was successful and *1* if not.

*-h, --help*::
  Show command line usage and help.

*-p, --print*::
  Print out the rules that are in effect in a tabular format. If you don't
  want to run the *PROGRAM*, you can use the *-c* option to exit after
  printing the rules.

*-r RULESPEC, --rule=RULESPEC*::
  A single rule for one particular socket to match, can be used several times
  to specify a set of rules similar to the sequence of the rule file.

*-f RULESFILE, --rules-file=RULESFILE*::
  Specifies a YAML or JSON file consisting of a sequence of rules.

*-F RULESDATA, --rules-data=RULESDATA*::
  Similar to *-f*, but instead of specifying a file, directly pass the contents
  as an argument.

endif::[]

== Rule specification

Arguments specified via *-r* contain a comma-separated list of either flags or
options. If a value contains a comma (`,`), it has to be escaped using a
backslash (`\`) character. If you want to have a verbatim backslash character
just use it twice (`\\`).

The following flags are available:

*in* | *out*::
  Corresponds to the <<rule-opt-direction,*`direction`*>> rule file option and
  if it's not set, both incoming and outgoing connections are matched.

*tcp* | *udp*::
  Either match TCP or UDP sockets or both if none of these flags are set
  (<<rule-opt-type,*`type`*>> rule file option).

ifndef::without-systemd[]
ifndef::systemd-no-fdnames[]
*systemd[=FD_NAME]*::
  Enable systemd socket activation
  (see <<rule-opt-socket-activation,*`socketActivation`*>> below), optionally
  specifying a file descriptior name (<<rule-opt-fdname,*`fdName`*>>).
endif::systemd-no-fdnames[]
ifdef::systemd-no-fdnames[]
*systemd*::
  Enable systemd socket activation
  (see <<rule-opt-socket-activation,*`socketActivation`*>> below).
endif::systemd-no-fdnames[]
endif::[]

*reject[=ERRNO]*::
  Reject calls to *connect* and *bind* with *`EACCES`* by default or the
  *`ERRNO`* specified either via name or as an integer.

*blackhole*::
  When binding the socket, use a temporary file system path and *unlink* it
  shortly after the *bind*. This is a way to deactivate a specific socket
  without the application noticing.

These options are available:

*addr[ess]=ADDR*::
  Optional, specifies an IPv4 or IPv6 address, see
  <<rule-opt-address,*`address`*>> rule file option.

*port=PORT*::
  Optional, specifies a port to match, see <<rule-opt-port,*`port`*>> rule file
  option.

*path=SOCKET_PATH*::
  The path to the socket file to either bind or connect to, see
  <<rule-socket-path,*`socketPath`*>> rule file option.

== Rule file format

The rule file (specified via *-f* is a YAML file (or JSON, as it is a subset of
YAML), consisting of an array of objects.

Each object consists of keys/values which define which IP sockets to match
and which Unix domain sockets to assign them to.

=== Rule file options

[[rule-opt-direction]]*`direction`*::

Whether this rule applies to a server-side socket (*`incoming`*), a client-side
socket (*`outgoing`*) or both if not defined.

[[rule-opt-type]]*`type`*::

Specifies the IP type, which currently is either *`tcp`* for TCP sockets,
*`udp`* for UDP sockets or if it's not defined it matches both UDP and TCP
sockets.

[[rule-opt-address]]*`address`*::

The IP address to match, which can be either an IPv4 or an IPv6 address.

[[rule-opt-port]]*`port`*::

UDP or TCP port number (depending on which <<rule-opt-type,*`type`*>> is set),
which for outgoing connections specifies the target port and for incomping
connections the port that the socket is bound to.

[[rule-socket-path]]*`socketPath`*::

The path to the socket file to use for either binding or connecting to
depending on whether the above options apply for a particular IP socket.
+
Placeholders are allowed here and those are substituted accordingly:
+
[horizontal]
*`%p`*;; port number
*`%a`*;; IP address or *`unknown`*
*`%t`*;; socket type (*`tcp`*, *`udp`* or *`unknown`*)
*`%%`*;; verbatim *`%`*

ifndef::without-systemd[]
[[rule-opt-socket-activation]]*`socketActivation`*::
ifndef::manmanual[]
If *`ip2unix`* is compiled with systemd support, whether to use socket
activation
endif::[]
ifdef::manmanual[]
Whether to use systemd socket activation
endif::[]
instead of a <<rule-socket-path,*`socketPath`*>>. See {systemd_socket}.

ifndef::systemd-no-fdnames[]
[[rule-opt-fdname]]*`fdName`*::
An optional file descriptor name for socket activation which can be used to
distinguish between several socket units. This corresponds to the {fdname}
systemd socket option.
endif::systemd-no-fdnames[]
endif::[]

*`reject`*::
  If true, reject calls to *connect* and *bind* with *`EACCES`*.

*`rejectError`*:
  Specifies an alternative error code to be returned by
  <<rule-reject,*`reject`*>> instead of *`EACCES`*. This can be either a string
  such as *`EADDRINUSE`* (case doesn't matter) or an integer.

*`blackhole`*::
  If true, a temporary file system path is used and unlinked shortly
  thereafter, so the socket is effectively deactivated in a way that the
  application should not recognize. Only valid if
  <<rule-opt-direction,*`direction`*>> is *`incoming`*.

== Examples

=== Simple HTTP client/server

On the server side with the rule file *`rules-server.yaml`*:

[source,yaml]
---------------------------------------------------------------------
- direction: incoming
  socketPath: /tmp/test.socket
---------------------------------------------------------------------

The following command spawns a small test web server listening on
*`/tmp/test.socket`*:

[source,sh-session]
---------------------------------------------------------------------
$ ip2unix -f rules-server.yaml python -m SimpleHTTPServer 8000
---------------------------------------------------------------------

The same can be achieved using *-r*:

[source,sh-session]
---------------------------------------------------------------------
$ ip2unix -r in,path=/tmp/test.socket python -m SimpleHTTPServer 8000
---------------------------------------------------------------------

On the client side with *`rules-client.yaml`*:

[source,yaml]
---------------------------------------------------------------------
- direction: outgoing
  socketPath: /tmp/test.socket
---------------------------------------------------------------------

This connects to the test server listening on *`/tmp/test.socket`*
and should show the directory listing:

[source,sh-session]
---------------------------------------------------------------------
$ ip2unix -f rules-client.yaml curl http://1.2.3.4/
---------------------------------------------------------------------

With the *-r* option:

[source,sh-session]
---------------------------------------------------------------------
$ ip2unix -r out,path=/tmp/test.socket curl http://1.2.3.4/
---------------------------------------------------------------------

=== More complicated example

[source,yaml]
--------------------------------------------
- direction: outgoing                 ## <1>
  type: tcp
  socketPath: /run/some.socket
- direction: incoming                 ## <2>
  address: 1.2.3.4
  socketPath: /run/another.socket
- direction: incoming                 ## <3>
  port: 80
  address: abcd::1
  blackhole: true
- direction: incoming                 ## <4>
  port: 80
  reject: true
  rejectError: EADDRINUSE
ifndef::without-systemd[]
- direction: incoming                 ## <5>
  type: tcp
  port: 22
  socketActivation: true
ifndef::systemd-no-fdnames[]
  fdName: ssh
endif::systemd-no-fdnames[]
endif::without-systemd[]
--------------------------------------------

<1> This rule will redirect *all* TCP connections to the Unix domain socket at
    *`/run/some.socket`*.
<2> Matches the socket that listens to any port on the IPv4 address *`1.2.3.4`*
    and instead binds it to the Unix domain socket at *`/run/another.socket`*.
<3> The application may bind to the IPv6 address *`abcd::1`* on port 80 but it
    won't get any connections, because no socket path exists.
<4> Trying to bind to port 80 on addresses other than *`abcd::1`* will result
    in an *`EADDRINUSE`* error.
ifndef::without-systemd[]
<5> Will prevent the TCP socket that would listen on port 22 to not listen at
    all and instead use
ifndef::systemd-no-fdnames[]
    the systemd-provided file descriptor named *`ssh`*
endif::systemd-no-fdnames[]
ifdef::systemd-no-fdnames[]
    the first systemd-provided file descriptor available
endif::systemd-no-fdnames[]
    for operations like {syscall_accept}.
endif::[]

The same can be achieved solely using *-r* commandline arguments:

ifndef::systemd-no-fdnames[:example_fdname_arg: =ssh]
ifdef::systemd-no-fdnames[:example_fdname_arg:]

[source,sh-session]
[subs="attributes"]
----------------------------------------------------------------------------
$ ip2unix -r out,tcp,path=/run/some.socket \
          -r in,addr=1.2.3.4,path=/run/another.socket \
          -r in,port=80,reject=EADDRINUSE {systemd_backslash}
ifndef::without-systemd[]
          -r in,tcp,port=22,systemd{example_fdname_arg}
endif::without-systemd[]
----------------------------------------------------------------------------

ifdef::manmanual[]

== Environment variables

`IP2UNIX_RULE_FILE`::
  When used in conjunction with {LD_PRELOAD}, this environment variable has to
  be set as well, specifying the absolute path to the rule file (see
  {rulefileformat} above).

== See also

*accept*(2),
*bind*(2),
*connect*(2),
*listen*(2),
*socket*(2){systemd_comma}
ifndef::without-systemd[*systemd.socket*(5)]

endif::[]

ifndef::manmanual[]

== Similar projects

https://cwrap.org/socket_wrapper.html[socket_wrapper]::

The goal is a different one here and its main use is testing. Instead of
using rules, *socket_wrapper* turns *all* of the IP sockets into Unix sockets
and uses a central directory to do the mapping.
+
Containing all Unix sockets into one directory has the nice effect that it's
easy to map *any* address/port combination to Unix sockets. While this is way
easier to implement than our approach it has the drawback that everything is
contained and no IP communication is possible anymore.

== Thanks

Special thanks to the https://nlnet.nl/[NLnet foundation] for sponsoring this
work.

endif::[]

ifdef::manmanual[]

== Author

Written by aszlig <aszlig@nix.build>

endif::[]

== Copyright

Copyright (C) 2018 aszlig. License LGPLv3: GNU LGPL version 3 only
<{lgpl_url}>.

This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

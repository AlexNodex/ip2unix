= ip2unix(1)
ifndef::manmanual[:doctitle: IP2Unix]
:revdate: October 2018
ifndef::manmanual[]
:toc: macro
:numbered:
:toc-title:

*Table of Contents*

toc::[]
endif::[]

ifdef::manmanual[]
== Name

ip2unix - Turn IP sockets into Unix domain sockets

== Synopsis

*ip2unix* [-p] -f RULES_FILE        PROGRAM [ARGS...] +
*ip2unix* [-p] -F RULES_DATA        PROGRAM [ARGS...] +
*ip2unix* [-p] -r RULE [-r RULE]... PROGRAM [ARGS...] +
*ip2unix* [-p] -c -f RULES_FILE +
*ip2unix* [-p] -c -F RULES_DATA +
*ip2unix* [-p] -c -r RULE [-r RULE]... +
*ip2unix* -h

endif::[]

ifndef::manmanual[]
:1: http://man7.org/linux/man-pages/man8/ld.so.8.html#ENVIRONMENT
:2: http://man7.org/linux/man-pages/man2/accept.2.html
:3: https://www.freedesktop.org/software/systemd/man/systemd.socket.html
:4: pass:attributes,quotes[{3}#FileDescriptorName=]

:LD_PRELOAD: pass:attributes,quotes[*`LD_PRELOAD`* ({1}[*ld.so*(8)])]
:syscall_accept: pass:attributes,quotes[{2}[*accept*(2)]]
:systemd_socket: pass:attributes,quotes[{3}[*systemd.socket*(5)]]
:fdname: pass:attributes,quotes[{4}[FileDescriptorName]]
:rulefileformat: <<Rule file format>>
endif::[]
ifdef::manmanual[]
:LD_PRELOAD: pass:quotes[*`LD_PRELOAD`* (see *ld.so*(8))]
:syscall_accept: pass:quotes[*accept*(2)]
:systemd_socket: pass:quotes[*systemd.socket*(5)]
:fdname: pass:quotes[FileDescriptorName (see *systemd.socket*(5))]
:rulefileformat: pass:quotes[*RULE FILE FORMAT*]
endif::[]

:lgpl_url: https://www.gnu.org/licenses/lgpl-3.0.html

ifndef::without-systemd[:systemd_comma: ,]
ifdef::without-systemd[:systemd_comma:]

ifndef::without-systemd[:systemd_backslash: \]
ifdef::without-systemd[:systemd_backslash:]

== Description

Turns IP sockets into Unix domain socket based on a list of rules (see
{rulefileformat} below) specified via YAML/JSON file. This is done by the use
of {LD_PRELOAD} environment variable and you can either directly specify the
path of *`ip2unix`* via *`LD_PRELOAD`* or use the *`ip2unix`* command directly
(it is a library and executable at the same time).

In order for the direct *`LD_PRELOAD`* variant to work, you also have to
specify the *`IP2UNIX_RULE_FILE`* environment variable.

ifndef::manmanual[]

Use `ip2unix --help` or `man ip2unix` to see a detailed list of options
available.

== Build from source

=== Requirements

* https://mesonbuild.com/[Meson], at least version 0.46.0
* https://ninja-build.org/[Ninja], at least version 1.5
* https://github.com/jbeder/yaml-cpp[yaml-cpp], at least version 0.5.0
* {cpp} compiler supporting {cpp}17 (GNU G++ version 7.0 onwards)

.Optional dependencies:
* http://asciidoc.org/[AsciiDoc] or https://asciidoctor.org/[Asciidoctor] for
  generating the manpage
* https://www.freedesktop.org/wiki/Software/systemd/[systemd] development
  libraries to support socket activation
* https://pytest.org/[pytest] for running automated tests

=== Cloning the repository

The source code can be fetched via https://git-scm.com/[Git] using the
following command:

[source,sh-session]
---------------------------------------------------------------------
$ git clone https://github.com/nixcloud/ip2unix.git
---------------------------------------------------------------------

You will get an `ip2unix` directory inside your current working directory. All
of the following steps are to be performed inside this `ip2unix` directory.

==== Using the Nix package manager

This is the easiest and recommended way to compile it from source and it should
work on any distribution.

If you're not running https://nixos.org/[NixOS] you can install
https://nixos.org/nix/[Nix] via the following command:

[source,sh-session]
---------------------------------------------------------------------
$ curl https://nixos.org/nix/install | sh
---------------------------------------------------------------------

In order to build *ip2unix* issue the following command from the top of the
source tree:

[source,sh-session]
---------------------------------------------------------------------
$ nix-build
---------------------------------------------------------------------

This takes care of fetching the dependencies, building and running the test
suite. The resulting command can now be found in `result/bin/ip2unix`.

If you want to add the package to your user environment, you can install it
using the command:

[source,sh-session]
---------------------------------------------------------------------
$ nix-env -f . -i
---------------------------------------------------------------------

==== Debian and derivatives

Fetching the requirements on Debian 9 can be tricky because only GCC version 6
is available, so
<<Using the Nix package manager,using the Nix package manager>> is recommended
here as it doesn't interfere with the rest of the system.

However if you still want to build it on Debian 9, you can install `g++-7` from
testing. Please be aware that mixing packages from `testing` might update
unrelated packages and might make your system less stable.

In addition to the C++ compiler, the version of Meson on Debian 9 is too old as
well. However it can be installed from the Python Package Index using `pip`:

[source,sh-session]
---------------------------------------------------------------------
$ sudo apt-get install python3-pip
$ pip3 install meson
---------------------------------------------------------------------

After you're done getting a newer Meson and C++ compiler, you can use the
following command to install the other required dependencies:

[source,sh-session]
---------------------------------------------------------------------
$ sudo apt-get install ninja-build pkg-config libyaml-cpp-dev
---------------------------------------------------------------------

If you want to have a manpage and support for systemd socket activation:

[source,sh-session]
---------------------------------------------------------------------
$ sudo apt-get install asciidoctor libsystemd-dev
---------------------------------------------------------------------

In case you want to run the test suite, pytest is required:

[source,sh-session]
---------------------------------------------------------------------
$ sudo apt-get install python3-pytest
---------------------------------------------------------------------

==== RPM-based distributions

On Fedora 29, all of the dependencies are recent enough, so in order to install
the required dependencies:

[source,sh-session]
---------------------------------------------------------------------
$ sudo yum install meson gcc-c++ yaml-cpp-devel
---------------------------------------------------------------------

The optional dependencies for the manpage and for systemd socket activation:

[source,sh-session]
---------------------------------------------------------------------
$ sudo yum install asciidoctor systemd-devel
---------------------------------------------------------------------

If you want to run the test suite:

[source,sh-session]
---------------------------------------------------------------------
$ sudo yum install python3-pytest
---------------------------------------------------------------------

==== Arch Linux and derivatives

To install the required dependencies:

[source,sh-session]
---------------------------------------------------------------------
$ sudo pacman -S yaml-cpp meson gcc pkg-config
---------------------------------------------------------------------

If you want to have the manpage:

[source,sh-session]
---------------------------------------------------------------------
$ sudo pacman -S asciidoctor
---------------------------------------------------------------------

In case you want to run the test suite:

[source,sh-session]
---------------------------------------------------------------------
$ sudo pacman -S python-pytest
---------------------------------------------------------------------

=== Building

[source,sh-session]
---------------------------------------------------------------------
$ meson build
---------------------------------------------------------------------

If you want to specify a different compiler executable, eg. `g++-7`:

[source,sh-session]
---------------------------------------------------------------------
$ CXX=g++-7 meson build
---------------------------------------------------------------------

Compile:

[source,sh-session]
---------------------------------------------------------------------
$ ninja -C build
---------------------------------------------------------------------

The executable is then placed in `build/ip2unix`, so to show the usage:

[source,sh-session]
---------------------------------------------------------------------
$ build/ip2unix --help
---------------------------------------------------------------------

=== Installation

To install *ip2unix*, run the following command:

[source,sh-session]
---------------------------------------------------------------------
$ ninja -C build install
---------------------------------------------------------------------

By default, this will install *ip2unix* in `/usr/local/bin/ip2unix`.

=== Running tests

[source,sh-session]
---------------------------------------------------------------------
$ ninja -C build test
---------------------------------------------------------------------

endif::[]

ifdef::manmanual[]

== Options

*-c, --check*::
  This is to validate whether the rule file is correct and the program
  just prints all validation errors to stderr and exits with exit code *0*
  if validation was successful and *1* if not.

*-h, --help*::
  Show command line usage and help.

*-p, --print*::
  Print out the rules that are in effect in a tabular format. If you don't
  want to run the *PROGRAM*, you can use the *-c* option to exit after
  printing the rules.

*-r RULESPEC, --rule=RULESPEC*::
  A single rule for one particular socket to match, can be used several times
  to specify a set of rules similar to the sequence of the rule file.

*-f RULESFILE, --rules-file=RULESFILE*::
  Specifies a YAML or JSON file consisting of a sequence of rules.

*-F RULESDATA, --rules-data=RULESDATA*::
  Similar to *-f*, but instead of specifying a file, directly pass the contents
  as an argument.

endif::[]

== Rule specification

Arguments specified via *-r* contain a comma-separated list of either flags or
options. If a value contains a comma (`,`), it has to be escaped using a
backslash (`\`) character. If you want to have a verbatim backslash character
just use two consecutive backslashes instead.

The following flags are available:

*in* | *out*::
  Corresponds to the <<rule-opt-direction,*`direction`*>> rule file option and
  if it's not set, both incoming and outgoing connections are matched.

*tcp* | *udp*::
  Either match TCP or UDP sockets or both if none of these flags are set
  (<<rule-opt-type,*`type`*>> rule file option).

ifndef::without-systemd[]
ifndef::systemd-no-fdnames[]
*systemd[=FD_NAME]*::
  Enable systemd socket activation
  (see <<rule-opt-socket-activation,*`socketActivation`*>> below), optionally
  specifying a file descriptior name (<<rule-opt-fdname,*`fdName`*>>).
endif::systemd-no-fdnames[]
ifdef::systemd-no-fdnames[]
*systemd*::
  Enable systemd socket activation
  (see <<rule-opt-socket-activation,*`socketActivation`*>> below).
endif::systemd-no-fdnames[]
endif::[]

*reject[=ERRNO]*::
  Reject calls to *connect* and *bind* with *`EACCES`* by default or the
  *`ERRNO`* specified either via name or as an integer.

*blackhole*::
  When binding the socket, use a temporary file system path and *unlink* it
  shortly after the *bind*. This is a way to deactivate a specific socket
  without the application noticing.

These options are available:

*addr[ess]=ADDR*::
  Optional, specifies an IPv4 or IPv6 address, see
  <<rule-opt-address,*`address`*>> rule file option.

*port=PORT[-PORT_END]*::
  Optional, specifies a port to match, see the <<rule-opt-port,*`port`*>> and
  optionally the <<rule-opt-port-end,*`portEnd`*>> rule file option if you want
  to specify a port range.

*path=SOCKET_PATH*::
  The path to the socket file to either bind or connect to, which is similar to
  the <<rule-socket-path,*`socketPath`*>> rule file option but also allows
  relative paths.

== Rule file format

The rule file (specified via *-f* is a YAML file (or JSON, as it is a subset of
YAML), consisting of an array of objects.

Each object consists of keys/values which define which IP sockets to match
and which Unix domain sockets to assign them to.

=== Rule file options

[[rule-opt-direction]]*`direction`*::

Whether this rule applies to a server-side socket (*`incoming`*), a client-side
socket (*`outgoing`*) or both if not defined.

[[rule-opt-type]]*`type`*::

Specifies the IP type, which currently is either *`tcp`* for TCP sockets,
*`udp`* for UDP sockets or if it's not defined it matches both UDP and TCP
sockets.

[[rule-opt-address]]*`address`*::

The IP address to match, which can be either an IPv4 or an IPv6 address.

[[rule-opt-port]]*`port`*::

UDP or TCP port number (depending on which <<rule-opt-type,*`type`*>> is set),
which for outgoing connections specifies the target port and for incomping
connections the port that the socket is bound to.

[[rule-opt-port-end]]*`portEnd`*::

Optionally specifies the end of a port range to match, so for example if
<<rule-opt-port,*`port`*>> is `2000` and *`portEnd`* is `3000` all ports in the
range from 2000 to 3000 (inclusive) are matched.

[[rule-socket-path]]*`socketPath`*::

The path to the socket file to use for either binding or connecting to
depending on whether the above options apply for a particular IP socket.
+
Placeholders are allowed here and those are substituted accordingly:
+
[horizontal]
*`%p`*;; port number
*`%a`*;; IP address or *`unknown`*
*`%t`*;; socket type (*`tcp`*, *`udp`* or *`unknown`*)
*`%%`*;; verbatim *`%`*

ifndef::without-systemd[]
[[rule-opt-socket-activation]]*`socketActivation`*::
ifndef::manmanual[]
If *`ip2unix`* is compiled with systemd support, whether to use socket
activation
endif::[]
ifdef::manmanual[]
Whether to use systemd socket activation
endif::[]
instead of a <<rule-socket-path,*`socketPath`*>>. See {systemd_socket}.

ifndef::systemd-no-fdnames[]
[[rule-opt-fdname]]*`fdName`*::
An optional file descriptor name for socket activation which can be used to
distinguish between several socket units. This corresponds to the {fdname}
systemd socket option.
endif::systemd-no-fdnames[]
endif::[]

[[rule-reject]]*`reject`*::
  If true, reject calls to *connect* and *bind* with *`EACCES`*.

*`rejectError`*:
  Specifies an alternative error code to be returned by
  <<rule-reject,*`reject`*>> instead of *`EACCES`*. This can be either a string
  such as *`EADDRINUSE`* (case doesn't matter) or an integer.

*`blackhole`*::
  If true, a temporary file system path is used and unlinked shortly
  thereafter, so the socket is effectively deactivated in a way that the
  application should not recognize. Only valid if
  <<rule-opt-direction,*`direction`*>> is *`incoming`*.

== Examples

=== Simple HTTP client/server

On the server side with the rule file *`rules-server.yaml`*:

[source,yaml]
---------------------------------------------------------------------
- direction: incoming
  socketPath: /tmp/test.socket
---------------------------------------------------------------------

The following command spawns a small test web server listening on
*`/tmp/test.socket`*:

[source,sh-session]
---------------------------------------------------------------------
$ ip2unix -f rules-server.yaml python -m SimpleHTTPServer 8000
---------------------------------------------------------------------

The same can be achieved using *-r*:

[source,sh-session]
---------------------------------------------------------------------
$ ip2unix -r in,path=/tmp/test.socket python -m SimpleHTTPServer 8000
---------------------------------------------------------------------

On the client side with *`rules-client.yaml`*:

[source,yaml]
---------------------------------------------------------------------
- direction: outgoing
  socketPath: /tmp/test.socket
---------------------------------------------------------------------

This connects to the test server listening on *`/tmp/test.socket`*
and should show the directory listing:

[source,sh-session]
---------------------------------------------------------------------
$ ip2unix -f rules-client.yaml curl http://1.2.3.4/
---------------------------------------------------------------------

With the *-r* option:

[source,sh-session]
---------------------------------------------------------------------
$ ip2unix -r out,path=/tmp/test.socket curl http://1.2.3.4/
---------------------------------------------------------------------

=== More complicated example

[source,yaml]
--------------------------------------------
- direction: outgoing                 ## <1>
  type: tcp
  socketPath: /run/some.socket
- direction: incoming                 ## <2>
  address: 1.2.3.4
  socketPath: /run/another.socket
- direction: incoming                 ## <3>
  port: 80
  address: abcd::1
  blackhole: true
- direction: incoming                 ## <4>
  port: 80
  reject: true
  rejectError: EADDRINUSE
ifndef::without-systemd[]
- direction: incoming                 ## <5>
  type: tcp
  port: 22
  socketActivation: true
ifndef::systemd-no-fdnames[]
  fdName: ssh
endif::systemd-no-fdnames[]
endif::without-systemd[]
--------------------------------------------

<1> This rule will redirect *all* TCP connections to the Unix domain socket at
    *`/run/some.socket`*.
<2> Matches the socket that listens to any port on the IPv4 address *`1.2.3.4`*
    and instead binds it to the Unix domain socket at *`/run/another.socket`*.
<3> The application may bind to the IPv6 address *`abcd::1`* on port 80 but it
    won't get any connections, because no socket path exists.
<4> Trying to bind to port 80 on addresses other than *`abcd::1`* will result
    in an *`EADDRINUSE`* error.
ifndef::without-systemd[]
<5> Will prevent the TCP socket that would listen on port 22 to not listen at
    all and instead use
ifndef::systemd-no-fdnames[]
    the systemd-provided file descriptor named *`ssh`*
endif::systemd-no-fdnames[]
ifdef::systemd-no-fdnames[]
    the first systemd-provided file descriptor available
endif::systemd-no-fdnames[]
    for operations like {syscall_accept}.
endif::[]

The same can be achieved solely using *-r* commandline arguments:

ifndef::systemd-no-fdnames[:example_fdname_arg: =ssh]
ifdef::systemd-no-fdnames[:example_fdname_arg:]

[source,sh-session]
[subs="attributes"]
----------------------------------------------------------------------------
$ ip2unix -r out,tcp,path=/run/some.socket \
          -r in,addr=1.2.3.4,path=/run/another.socket \
          -r in,port=80,reject=EADDRINUSE {systemd_backslash}
ifndef::without-systemd[]
          -r in,tcp,port=22,systemd{example_fdname_arg}
endif::without-systemd[]
----------------------------------------------------------------------------

== Limitations

If a client which is already using Unix *datagram* sockets sends packets via
*`sendto`* or *`sendmsg`* to a socket provided by *ip2unix* without binding
first, *ip2unix* is not able to identify the peer and will subsequently reject
the packet. This is not the case when using *ip2unix* itself on the the client
side and it also doesn't seem to be very common as the author so far didn't
find such an application in the wild.

However, if this really is an issue to you, the recommended workaround is
either to use *ip2unix* to wrap the client (if it supports IP sockets) or fix
the server to natively use Unix domain sockets.

ifdef::manmanual[]

== Environment variables

`IP2UNIX_RULE_FILE`::
  When used in conjunction with {LD_PRELOAD}, this environment variable has to
  be set as well, specifying the absolute path to the rule file (see
  {rulefileformat} above).

== See also

*accept*(2),
*bind*(2),
*connect*(2),
*listen*(2),
*recvfrom*(2),
*recvmsg*(2),
*sendmsg*(2),
*sendto*(2),
*socket*(2),
*unix*(7){systemd_comma}
ifndef::without-systemd[*systemd.socket*(5)]

endif::[]

ifndef::manmanual[]

== Similar projects

https://cwrap.org/socket_wrapper.html[socket_wrapper]::

The goal is a different one here and its main use is testing. Instead of
using rules, *socket_wrapper* turns *all* of the IP sockets into Unix sockets
and uses a central directory to do the mapping.
+
Containing all Unix sockets into one directory has the nice effect that it's
easy to map *any* address/port combination to Unix sockets. While this is way
easier to implement than our approach it has the drawback that everything is
contained and no IP communication is possible anymore.

== Thanks

Special thanks to the https://nlnet.nl/[NLnet foundation] for sponsoring this
work.

endif::[]

ifdef::manmanual[]

== Author

Written by aszlig <aszlig@nix.build>

endif::[]

== Copyright

Copyright (C) 2018 aszlig. License LGPLv3: GNU LGPL version 3 only
<{lgpl_url}>.

This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

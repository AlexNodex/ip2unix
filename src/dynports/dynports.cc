// SPDX-License-Identifier: LGPL-3.0-only
#include <chrono>
#include <random>

#include <sys/types.h>
#include <unistd.h>

#include "dynports.hh"

/*
 * This is an array of port offsets which is generated by genoffsets.py in the
 * same directory and will be substituted here accordingly.
 */
@PORT_OFFSETS@

static std::default_random_engine initalize_generator(void)
{
    auto now = std::chrono::system_clock::now();
    uint64_t seed = now.time_since_epoch().count() ^ getpid();
    std::default_random_engine gen(seed);
    return gen;
}

static std::default_random_engine generator = initalize_generator();

static uint16_t get_random_port(void)
{
    std::uniform_int_distribution<> dist(1024, 65535);
    return dist(generator);
}

/*
 * Here we get a random offset from PORT_OFFSETS, which is an array of primes
 * which are not a multiple of the ephemeral port range (from 1024 to 65535).
 *
 * The reason we do this is is to assign ports in a non-incremental way but
 * just adding the offset everytime we acquire() a new port.
 */
static uint16_t get_random_offset(void)
{
    std::uniform_int_distribution<> dist(0, PORT_OFFSETS.size() - 1);
    return PORT_OFFSETS[dist(generator)];
}

DynPorts::DynPorts()
    : reserved()
    , current(get_random_port())
    , offset(get_random_offset())
{
}

uint16_t DynPorts::rotate_port(uint16_t port, uint16_t off) const
{
    uint32_t tries = 0;
    uint32_t bounds = 65536 - 1024;

    do {
        uint32_t base = port - 1024;
        base = (base + off) % bounds;
        port = base + 1024;

        if (++tries > bounds)
            throw std::overflow_error("Ephemeral ports exhausted");
    } while (this->reserved.find(port) != this->reserved.end());

    return port;
}

uint16_t DynPorts::acquire(void) {
    return this->current = this->rotate_port(this->current, this->offset);
}

uint16_t DynPorts::reserve(uint16_t port)
{
    if (port == 0) {
        port = get_random_port();
        if (this->reserved.find(port) != this->reserved.end())
            port = this->rotate_port(port, 1);
    }

    this->reserved.emplace(port);
    return port;
}
